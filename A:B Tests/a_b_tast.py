# -*- coding: utf-8 -*-
"""A/B tast.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oWFdDjRZDYpShyyFR4BLNGZlWzPUdzzx

Case: A/B Test for Mobile Application.

There is a mobile application for a food store selling groceries. The hypothesis is that changing fonts will improve service quality in terms of the number of customers performing each event. To test this hypothesis, a decision was made to conduct an A/B test.

It was agreed to make a decision based on the results of the A/B test.
Users were divided into 2 groups: 247 - control group with old fonts (this is a different group compared to the one analyzed); 248 - experimental group with new fonts.

Description of the Data

|Feature|Comment|
|--:|:--|
|`EventName`|Event name|
|`DeviceIDHash`| Unique user identifier|
|`EventTimestamp`| Event time|
|`ExpId`| Group number|
"""

import pandas as pd
import numpy as np

import datetime as dt

import seaborn as sns
import matplotlib.pyplot as plt

df = pd.read_csv('/content/ab_test.csv')
df

"""# New Section"""

df.info()

df.ExpId.value_counts()

df.drop_duplicates(keep = False, inplace = True )

A = set(df[df.ExpId == 246].DeviceIDHash.unique())
B = set(df[df.ExpId == 248].DeviceIDHash.unique())
A.intersection(B)

df.rename(columns = {'EventName' : 'event_name',
                     'DeviceIDHash' : 'device_id',
                     'EventTimestamp' : 'event_time',
                     'ExpId' : 'group_id'}, inplace = True)
df

df['event_time'] = pd.to_datetime(df['event_time'])

df = df.astype({'group_id' : 'str',
           'device_id' : 'str'})

df.info()

df.groupby('device_id').agg(count_device_id = ('device_id', 'count')).\
reset_index().\
sort_values(by = 'count_device_id', ascending = False)

#How many total events?
#How many total users in the log?
#What is the average number of events per user?

print("""
Total events: {}.
Unique events {}: {}.
Unique users: {}.
On average, {} events per user.
""".format(df.shape[0],
           df.event_name.nunique(),
           ', '.join(df.event_name.unique()),
           df.device_id.nunique(),
           int(df.shape[0] / df.device_id.nunique())
           ))

#Test period: maximum and minimum dates;
#Histogram by date and number of events
print("""
The test started {}.
The test ended {}.
""".format(df.event_time.min(),
           df.event_time.max()
           )
)

df['event_date'] = df['event_time'].dt.date

df[['event_time', 'event_date']]

df_count_eve_day = df.groupby('event_date').agg(count_event_day = ('event_name', 'count')).\
reset_index()

df_count_eve_day

# Histogram by date and number of events
ax = sns.barplot(data = df_count_eve_day,
            x = 'event_date',
            y = 'count_event_day')
ax.set_xticklabels(ax.get_xticklabels(), rotation = 45, fontsize = 6);
plt.xlabel('')
plt.ylabel('')
plt.title('')
plt.tight_layout()

df_ok = df[df.event_date >= dt.datetime(2019, 8, 1).date()]

df_ok.group_id.value_counts()

#Event distribution: which events and in what quantity.
df_ok.groupby('event_name').agg(count_event = ('device_id', 'count')).\
reset_index().\
sort_values(by = 'count_event', ascending = False)

#How many unique users performed each of these events?
df_ok.groupby('event_name').agg(count_users = ('device_id', 'nunique')).\
reset_index().\
sort_values(by = 'count_users', ascending = False)

df_ok.device_id.nunique()

#Event funnel: what proportion of users move to the next step in the funnel.
#At which step do you lose the most users?
#What proportion of users make it from the first event to payment?

df

df.info()

#Building a funnel
#Let's calculate the number of unique users who performed the events, grouped by groups.
df_all_groups = pd.merge(df_ok[df_ok.group_id == '247'].groupby('event_name').\
         agg(count_users_in_247 = ('device_id', 'nunique')).\
         reset_index().\
         sort_values(by = 'count_users_in_247', ascending = False),
         df_ok[df_ok.group_id == '248'].groupby('event_name').\
         agg(count_users_in_248 = ('device_id', 'nunique')).\
         reset_index().\
         sort_values(by = 'count_users_in_248', ascending = False))

df_all_groups

df_all_groups.event_name.unique()

select_event = ['MainScreenAppear', 'OffersScreenAppear',
              'CartScreenAppear', 'PaymentScreenSuccessful']
df_all_groups = df_all_groups.loc[df_all_groups.event_name.isin(select_event)]

ax = sns.barplot(data = df_all_groups,
                 x = 'count_users_in_247',
                 y = 'event_name')
for bars in ax.containers:
    ax.bar_label(bars, rotation=45)
plt.xlabel('')
plt.ylabel('')
plt.title('')
plt.tight_layout()

from plotly import graph_objects as go

fig = go.Figure()

fig.add_trace(go.Funnel(
    name = 'Group 247',
    orientation = "h",
    y = df_all_groups['event_name'],
    x = df_all_groups['count_users_in_247'],
    textposition = "inside",
    textinfo = "value+percent total+percent previous"))

fig.add_trace(go.Funnel(
    name = 'Group 248',
    orientation = "h",
    y = df_all_groups['event_name'],
    x = df_all_groups['count_users_in_248'],
    textposition = "inside",
    textinfo = "value+percent total+percent previous"))

fig.show()

#Analysis of experiment results
#How many users in each group?
#Calculate the proportion of users who performed each of the events.
#Test the hypothesis of significant differences in test results.

#How many users are in each group?
count_users = df_ok.groupby('group_id').agg(unique_users_group = ('device_id', 'nunique'))
count_users

df_all_groups

#Calculate the proportion of users who performed each of the events.
df_all_groups.loc[:, 'percent_user_group_247'] = df_all_groups['count_users_in_247'] / count_users.loc['247'][0]
df_all_groups.loc[:, 'percent_user_group_248'] = df_all_groups['count_users_in_248'] / count_users.loc['248'][0]
df_all_groups

#
#here are no statistically significant differences in the number of users who performed each event across groups 247 and 248 (a = b).
#_0: The difference between the number of unique clients in each group who performed a certain event is not statistically significant (a - b = 0).
#H_1: There are statistically significant differences in the number of users who performed each event across groups 247 and 248.
#Changing the color to green will increase revenue by 48%.
#H_0: There are no statistically significant differences in the cumulative revenue volumes between groups A and B.

df_all_groups.index = df_all_groups.event_name
df_all_groups

df_all_groups.loc['MainScreenAppear', 'percent_user_group_247']

import math
import scipy.stats as st


def z_test(group1, group2, event, alpha):
    p1_ev = df_all_groups.loc[event, group1]
    p2_ev = df_all_groups.loc[event, group2]
    p1_us = count_users.loc['247'][0]
    p2_us = count_users.loc['248'][0]
    p1 = p1_ev / p1_us
    p2 = p2_ev / p2_us
    difference = p1 - p2
    p_combined = (p1_ev + p2_ev) / (p1_us + p2_us)
    z_value = difference / math.sqrt(p_combined * (1 - p_combined) * (1 / p1_us + 1 / p2_us))
    distr = st.norm(0, 1)
    p_value = (1 - distr.cdf(abs(z_value))) * 2
    print('Groups {} and {}. Event -- {}. P-Value --  {:.2f}. Significance level-- {}'.format(group1, group2, event, p_value, alpha ))
    if (p_value < alpha):
        print("Reject the null hypothesis -- There is a significant difference between the proportions")
    else:
        print("Failed to reject the null hypothesis, no grounds to consider the proportions different")

for event in df_all_groups.index:
    z_test('count_users_in_247', 'count_users_in_248', event, 0.05)

"""  
Based on the hypotheses that changing fonts will improve service quality in terms of the number of customers performing each event, the results show that:

Changing the website font does not affect revenue improvement, as evidenced by the customer event funnel.

Also, there are no statistically significant differences in the number of users who performed each event between groups 247 and 248.**

"""

